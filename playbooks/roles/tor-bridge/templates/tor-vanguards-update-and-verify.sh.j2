#!/usr/bin/env bash
set -eux

# Cronjob/utility script to fetch updates to the "vanguards" Tor add-on
# https://github.com/mikeperry-tor/vanguards

# This script uses the latest git tag of the repo and Mike Perry's PGP key ID
# grabbed from https://2019.www.torproject.org/docs/signing-keys.html.en
#
# N.B. this script should be idempotent and will exit early if git reports no changes

VANGUARD_REPO_DIR="{{ tor_vanguards_addon_directory }}"
VANGUARD_REPO_URL="{{ tor_vanguards_repo_url }}"
VANGUARD_SIGNING_KEY="{{ tor_vanguards_addon_gpg_key }}"

cd $VANGUARD_REPO_DIR
# Store currently checked out commit SHA in case anything fails.
# If we can't verify a new tag, we can checkout the old one which we know has been
# verified by Ansible during Streisand install.
VANGUARD_CURRENT_COMMIT=$(git show --format="%H" --no-patch)
VANGUARD_CURRENT_TAG=$(git describe --tags)

# Failsafe function to ensure we're checked out into the last "known" good git tag/commit
# This way, if a git pull/gpg verify/other command in this script fails, we can leave
# the vanguards git repo in a known "good state" and hopefully not break anything.
function git_checkout_known_tag() {
	git checkout $VANGUARD_CURRENT_COMMIT
}
trap git_checkout_known_tag ERR SIGINT SIGTERM SIGQUIT SIGKILL

function check_for_git_updates() {
	# Since individual commits aren't verified in the repo (only tags),
	# we compare the number of tags in the local repo vs the remote repo.
	# git ls-remote in this case communicates on the fly with the remote repo
	# for an up-to-date list of tags in the project. If we don't have any new
	# tags to fetch, we can exit early. We can even avoid doing "git fetch" this way.
	local local_tag_count=$(git tag -l | wc -l)
	# The grep -v is to strip away "tag references" which will show up for each annotated tag.
	# otherwise we get a bigger list of tags (e.g. "refs/tags/v0.0.1", "refs/tags/v0.0.1^{}" etc.)
	local remote_tag_count=$(git ls-remote --tags origin | grep -v "\^{}" | wc -l)
	if [ $local_tag_count == $remote_tag_count ]; then
		echo "Local/remote tag count is the same, nothing to do."
		exit 0
	fi
	# Repo has new tags, so we should do a fetch
	git fetch
}

function verify_and_update() {
	# Find latest available tag by sorting by "taggerdate" (date tag was created)
	# We also want to avoid ever checking out an alpha/beta/dev tag and only use "stable" tags
	LATEST_TAG=$(git tag -l --sort=-taggerdate | grep -v "alpha\|beta\|dev\|test" | head -n 1)
	# If it's the same tag we're currently using we don't need to do anything
	# (means we likely only fetched beta/dev tags)
	if [ "$LATEST_TAG" == "$VANGUARD_CURRENT_TAG" ]; then
		echo "Already on the latest stable tag. Nothing to do."
		exit 0
	fi

	# So now, we can finally verify!
	# This should have been run during install, but just in case, we always configure
	# git to use gpg2 instead of default /usr/bin/gpg
	git config --global gpg.program $(which gpg2)
	# Tell GPG which keyring to use (Streisand installs to a non-default location)
	export GNUPGHOME="{{ streisand_gpg_dir }}"
	# Make sure the verify-tag command is checking against the right signing key
	# --raw redirects output to stderr and gives us full raw output from gpg
	# if sig is valid we should find "VALIDSIG [...] KEY_ID_HERE" in the output
	git verify-tag --raw "$LATEST_TAG" 2>&1 | grep -q "VALIDSIG.*${VANGUARD_SIGNING_KEY#0x}"

	# If we get this far, we can confirm the latest tag is signed and should be OK to use.
	# (git verify-tag will exit with an error status if it doesn't succeed)
	# Now we can do a checkout of that tag inside the git repo.
	git checkout $LATEST_TAG

	# Restart the systemd service to run the updated code
	systemctl restart vanguards.service
}

check_for_git_updates
verify_and_update
exit $?
